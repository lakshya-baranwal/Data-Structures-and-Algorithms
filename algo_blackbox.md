# Blackbox

| Technique                           | Arguments (Input)                                                   | Returns (Output)                                                  | Constraints                                             | Complexity                                                            | Use-Cases                                                                                                                                                                                                                                                           | Template     |
| ----------------------------------- | ------------------------------------------------------------------- | ----------------------------------------------------------------- | ------------------------------------------------------- | --------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------ |
| **Binary Lifting (LCA)**            | • Tree `T` <br><br> • Queries `(u, v)` or `(u, k)`                  | • Lowest Common Ancestor <br><br> • k-th ancestor of node          | • `1 ≤ n ≤ 2e5`                                         | • Preprocessing: `O(n log n)` <br><br> • Query: `O(log n)`             | - Compute **Lowest Common Ancestors** quickly. <br><br> - Find **k-th ancestor** of a node in logarithmic time. <br><br> - Derive **distances between nodes** for path queries. <br><br> - Preprocess ancestor data for **tree DP** problems.                         | [Template]() |
| **Centroid Decomposition**          | • Tree `T` with `n` nodes <br><br> • Queries on paths/subtrees       | • Decomposition tree <br><br> • Query results (problem-dependent) | • `1 ≤ n ≤ 2e5` (typical) <br><br> • Tree must be connected | • Build: `O(n log n)` <br><br> • Queries: often `O(log n)`             | - Split trees into **balanced subtrees** for divide-and-conquer. <br><br> - Answer **distance-constrained queries** on trees (nearest colored node, bounded paths). <br><br> - Optimize problems requiring **repeated subtree/path processing**.                       | [Template]() |
| **Convex Hull Trick (CHT)**         | • Lines `(m, c)` <br><br> • Query points `x`                        | • Min/Max value at `x`                                            | • Queries must be monotonic in some variants            | • Insert/Query: `O(log n)`                                            | - Optimize DP recurrences of type `dp[i] = min(dp[j] + m·x + c)`. <br><br> - Solve **cost minimization/maximization** problems with linear transitions. <br><br> - Maintain convex/concave envelopes in **computational geometry**.                                    | [Template]() |
| **Convolution** | • Two sequences `A` and `B` | • Sequence `C` = convolution of `A` and `B` | • Integer or floating point coefficients | • `O(n log n)` with FFT/NTT | - Compute **sum over all pairwise products** efficiently. <br><br> - Solve **subset sum / ways to reach sum** problems. <br><br> - Use as building block for **FFT-based DP** or combinatorial problems. | [Template]() |
| **DSU (Union-Find)**                | • Set of elements <br><br> • Union/Find operations                   | • Connected components info                                       | • `1 ≤ n ≤ 1e6`                                         | • Amortized `O(α(n))` (inverse Ackermann, ~constant)                  | - Maintain **connectivity in dynamic graphs**. <br><br> - Detect **cycles** in undirected graphs. <br><br> - Build **Minimum Spanning Tree** (Kruskal’s algorithm). <br><br> - Group elements into **disjoint sets** with efficient merging.                           | [Template]() |
| **DSU on Tree (Sack)**              | • Tree `T` <br><br> • Node attributes                               | • Subtree query results                                           | • `1 ≤ n ≤ 2e5`                                         | • Amortized `O(n log n)`                                              | - Answer **queries about node attributes** within subtrees. <br><br> - Efficiently **merge frequency/count data** of children into parents. <br><br> - Count **distinct elements** (colors/values) in subtrees. <br><br> - Optimize **subtree aggregation queries**.      | [Template]() |
| **Fast Fourier Transform (FFT)** | • Two polynomials / arrays `A` and `B` <br><br> • Optional: modulus for double precision | • Convolution / coefficients of product polynomial | • Coefficients ≤ 1e6 for precision <br><br> • Preferably size as power of 2 | • `O(n log n)`                     | - Multiply **polynomials efficiently**. <br><br> - Compute **convolution / correlation** of sequences. <br><br> - Solve **combinatorial sum/product problems**. <br><br> - Fast **signal processing / pattern matching** in arrays. | [Template]() |
| **Fenwick Tree (BIT)**              | • Array `A` <br><br> • Point updates + prefix queries                | • Prefix sums / frequencies                                       | • `1 ≤ n ≤ 2e5`                                         | • Update: `O(log n)` <br><br> • Query: `O(log n)`                     | - Maintain **prefix sums dynamically**. <br><br> - Solve **inversion counting** in arrays. <br><br> - Answer **frequency/order-statistic queries** efficiently.                       | [Template](Range%20Query/fenwick_tree.cpp) |
| **Heavy-Light Decomposition (HLD)** | • Tree `T` <br><br> • Path queries `(u, v)`                         | • Path query results (sum, min, max, gcd)                         | • `1 ≤ n ≤ 2e5`                                         | • Preproc: `O(n)` <br><br> • Query/Update: `O(log² n)`                | - Decompose **paths into logarithmic chains** for queries. <br><br> - Support efficient **path queries** (sum, min, max, gcd). <br><br> - Apply **dynamic updates** on paths/subtrees. <br><br> - Combine with **segment tree/Fenwick tree** for advanced queries.      | [Template]() |
| **Lazy Segment Tree**               | • Array `A` <br><br> • Range updates + range queries                 | • Query results after updates                                     | • `1 ≤ n ≤ 2e5`                                         | • Build: `O(n)` <br><br> • Update/Query: `O(log n)`                   | - Perform efficient **range updates** (increment, assignment). <br><br> - Handle **interval scheduling** and modification queries. <br><br> - Solve problems with **repeated bulk updates**. <br><br> - Core structure in **range update + range query** scenarios.        | [Template]() |
| **Li Chao Tree**                    | • Lines `(m, c)` <br><br> • Query points `x`                        | • Min/Max value at `x`                                            | • `x` can be in arbitrary large coordinate range        | • Insert/Query: `O(log C)` where `C` = coordinate range               | - Maintain **dynamic set of linear functions**. <br><br> - Query **min/max for arbitrary `x` online**. <br><br> - Handle **large/unbounded coordinate ranges** without compression. <br><br> - Apply in **online DP optimization** where queries are unsorted.              | [Template]() |
| **Matrix Exponentiation**           | • Transition matrix `M` <br><br> • Integer `k`                       | • `M^k` result <br><br> • nth term of recurrence                  | • `k` up to `1e18`                                      | • `O(k³ log n)` for k×k matrix                                        | - Compute **nth term of linear recurrence**. <br><br> - Fast evaluation of **Fibonacci-like sequences**. <br><br> - Model **state transitions in DP** via matrix multiplication. <br><br> - Count **fixed-length walks in graphs** using adjacency matrix powers.        | [Template]() |
| **Mo’s Algorithm**                  | • Array `A` <br><br> • Queries `(l, r)`                             | • Query answers in original order                                 | • `1 ≤ n, q ≤ 2e5` <br><br> • Offline only              | • `O((n + q) √n)`                                                     | - Answer **offline range queries** by reordering them. <br><br> - Count **distinct elements** in arbitrary subarrays. <br><br> - Maintain **frequency-based answers** (mode, frequency counts). <br><br> - Efficient when **updates are absent** and queries are large.    | [Template]() |
| **Number Theoretic Transform (NTT)** | • Two integer polynomials / arrays `A` and `B` <br><br> • Modulus `MOD` (prime, 1 + k·2^n) | • Convolution modulo `MOD`                     | • Modulus must be special prime (`MOD = c*2^k+1`) <br><br> • Coefficients ≤ `MOD` | • `O(n log n)`                     | - Multiply polynomials **modulo a prime** exactly. <br><br> - Avoid floating-point errors of FFT. <br><br> - Solve **modular combinatorial convolutions**, e.g., counting sequences modulo prime. | [Template]() |
| **Persistent Segment Tree**         | • Array `A` <br><br> • Versions of array states                      | • Range query result from chosen version                          | • `1 ≤ n ≤ 2e5`                                         | • Build: `O(n log n)` <br><br> • Query: `O(log n)`                    | - Maintain **multiple versions** of array states without copying. <br><br> - Query **past versions** efficiently. <br><br> - Solve **k-th order statistic queries** in subarrays. <br><br> - Support **undo/rollback** operations in dynamic queries.                       | [Template]() |
| **Segment Tree (without Lazy)**     | • Array `A` <br><br> • Point updates + range queries                 | • Query results (sum, min, max, gcd, etc.)                        | • `1 ≤ n ≤ 2e5`                                         | • Build: `O(n)` <br><br> • Update: `O(log n)` <br><br> • Query: `O(log n)` | - Perform **range queries** (sum, min, max, gcd) efficiently. <br><br> - Support fast **point updates**. <br><br> - Combine with **HLD** for tree path queries. <br><br> - Base structure for many **advanced segment tree variants**.                              | [Template]() |
| **Sparse Table**                    | • Static array `A` <br><br> • Range queries                           | • Min/Max/GCD over range \[l,r]                                   | • `1 ≤ n ≤ 1e5` <br><br> • **Immutable array**          | • Build: `O(n log n)` <br><br> • Query: `O(1)`                        | - Preprocess **static arrays** for query speed. <br><br> - Perform **Range Minimum/Maximum Queries**. <br><br> - Compute **range GCDs** in constant time. <br><br> - Ideal when array is **immutable and queries are heavy**.                                    | [Template]() |
| **Sqrt Decomposition**              | • Array `A` <br><br> • Range queries and point updates               | • Range query results                                             | • `1 ≤ n ≤ 1e5`                                         | • Query: `O(√n)` <br><br> • Update: `O(√n)`                           | - Partition array into **blocks** for queries. <br><br> - Handle **range sum/min queries** under moderate limits. <br><br> - Good balance when **segment tree is too heavy**. <br><br> - Works with both **updates and queries** in simpler problems.                  | [Template]() |
| **Suffix Array**                    | • String `S` of length `n`                                           | • Array of suffix indices in lexicographic order                  | • `1 ≤ n ≤ 1e6`                                         | • Build: `O(n log n)` (or `O(n)` with SA-IS) <br><br> • LCP Array: `O(n)` | - Search **substrings efficiently** using binary search. <br><br> - Count **distinct substrings** of a string. <br><br> - Find **longest repeated** or **longest common substrings**. <br><br> - Serve as a foundation for **suffix automaton/tree** string problems.    | [Template]() |
